<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Présentation du projet Fic'Tif - BERNARD Nicolas</title>
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"
		/>
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/black.css"
		/>
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css"
		/>
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Page de garde -->
				<section>
					<h2>FicTif</h2>
					<p>Centre médical</p>
					<br />
					<p>Par Nicolas BERNARD</p>
					<img src="./image/SOFIP-logo-blanc.png" alt="logo sofip" />
				</section>

				<!-- Présentation personnelle -->
				<section>
					<h2>Parcours</h2>
					<section>
						<p class="fragment">DEUST IOSI - Mont Houy Valenciennes</p>
						<p class="fragment">Reconvertion professionnelle</p>
						<aside class="notes">
							<span>BAS</span>
							<br /><br />
							Cursus universitaire en DEUST IOSI (Informatique d'organisation et
							systèmes d'information) à Valenciennes. Découverte du
							développement web + appétence.
							<br /><br />
							<span>BAS</span>
							<br /><br />
							Entrée en formation suite à une reconversion.
							<br /><br />
							<span>&gt;&gt; DROIT</span>
						</aside>
					</section>
				</section>

				<!-- Introduction -->
				<section>
					<h2>La formation Sofip</h2>
					<p>Objectifs:</p>
					<ul>
						<li class="fragment">Dépoussiérer mes connaissances</li>
						<li class="fragment">Apprendre les nouvelles méthodes</li>
						<li class="fragment">Adopter les bonnes pratiques</li>
					</ul>
					<aside class="notes">
						Mes attentes :
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Dépoussiérer mes connaissances. A l'époque je n'avais vu que du PhP
						et les rudiments du HTML et du css. On avait pas effectuer de réel
						projet conséquent.
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Apprendre les nouvelles méthodes. Depuis la fin de mes études, les
						technologies du web ont bien évoluées. Je me devais de me mettre à
						jour.
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Adopter les bonnes pratiques. Profiter de l'expérience de notre
						formateur a été le réel intérêt de la formation. Avoir un retour
						d'expérience de sa part été crucial pour obtenir les outils
						nécessaires afin de travailler dans le monde du web.
						<br /><br />
						<span>&gt;&gt; BAS</span>
					</aside>
				</section>

				<!-- Présentation du projet -->
				<section>
					<h2>Présentation du projet</h2>
					<section>
						<h3>Thème</h3>
						<p>Application web de prise de rendez-vous médical</p>
						<aside class="notes">
							Dans mon dossier de projet j'explique les raisons qui m'ont
							poussées à faire ce choix à la première page.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Services devant être délivrés</h3>
						<ul>
							<li class="fragment">Prise de rendez-vous</li>
							<li class="fragment">Consulter la liste des rendez-vous</li>
							<li class="fragment">Gestion de compte utilisateur</li>
						</ul>
						<aside class="notes">
							Afin de réaliser une telle application, il est impératif qu'elle
							abrite un minimum de fonctionnalité, comme :
							<br /><br />
							<span>BAS</span>
							<br /><br />
							Gestion de prise de rendez-vous
							<br /><br />
							<span>BAS</span>
							<br /><br />
							Une page de consultation de la liste des rendez-vous
							<br /><br />
							<span>BAS</span>
							<br /><br />
							Une gestion de compte utilisateur
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Besoins fonctionnels</h3>
						<p>Exemple de besoins fonctionnels pour les patients :</p>
						<p class="fragment">
							Je dois être capable, si je suis connecté, d’atteindre la page de
							rendez-vous POUR prendre rendez-vous avec un médecin
						</p>
						<p class="fragment">
							Je dois être capable, sur la page de rendez-vous, de sélectionner
							un créneau horaire POUR réserver ce créneau pour mon rendez-vous
						</p>
						<aside class="notes">
							J'ai donc formulé des besoins fonctionnels afin de m'assurer des
							comportements des fonctionnalités. Ces besoins fonctionnels
							ressemble à ceci.
							<br /><br />
							<span>BAS</span>
							<br /><br />
							<span>BAS</span>
							<br /><br />
							J'ai appris par la suite que ce genre d'expression peut être
							retrouvé dans des Users Story, dans lesquels on peut également
							trouver d'autres spécificités métiers.
							<br /><br />
							<span>BAS</span>
							<br /><br />
							J’ai opté pour l’usage de Node.js et React pour le front end. J’ai
							décidé d’utiliser Express en complément de Node.js pour effectuer
							le backend. De cette façon j'ai un backend robuste qui emploi le
							même language que mon frontend pour plus de simplicité.
							<br /><br />
							<span>&gt;&gt; DROIT</span>
						</aside>
					</section>
				</section>

				<!-- Conception -->
				<section>
					<h2>Conception</h2>
					<section>
						<h3>Maquettage & Wireframes</h3>
						<h4>Index</h4>
						<img
							src="./image/Maquettage index.png"
							alt="Vue de l'index en wireframe"
						/>
						<aside class="notes">
							Je voulais une UI très simple, avec le moins de scroll possible
							pour que les informations soient facilement accessibles.
							<br /><br />
							On peut voir que sur la vue avec fonctionnalités il y a l'encart
							qui acceuillera les notifications suite aux actions de
							l'utilisateur.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h4>Prise de Rendez-vous</h4>
						<img
							src="./image/Maquettage Prise de Rendez-vous.png"
							alt="Vue de l'index en wireframe"
						/>
						<aside class="notes">
							Il fallait que la page de prise de rendez-vous permette de
							sélectionner la spécialité concernée, puis le médecin. J'ai donc
							décider de faire un formulaire avec des éléments selects pour ses
							valeurs.
							<br /><br />
							A ce moment de ma réflexion, je ne savais pas encore comment
							j'allais réaliser le calendrier.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h4>Page Profil</h4>
						<img
							src="./image/Maquettage Profil utilisateur.png"
							alt="Vue de l'index en wireframe"
						/>
						<aside class="notes">
							La page porfil a été ammenée à changer, surtout pour la partie
							Agenda. Le design que j'ai imaginé à la base ne s'est pas montré
							pratique à l'usage. Celui qui est en ligne ne me plait pas trop
							non plus.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Environnement de développement</h3>
						<img
							class="icon fragment"
							src="./image/github-icon-2.svg"
							alt="Icône de github"
						/>
						<img
							class="icon fragment"
							src="./image/png-transparent-visual-studio-code-hd-logo-thumbnail.png"
							alt="Icône de visual studio code"
						/>
						<aside class="notes">
							Avant de me lancer dans le développement de mon application, j'ai
							mis en place mon environnement de travail, pour ce faire, j'ai
							utilisé :
							<br /><br />
							<span>BAS</span>
							<br /><br />
							Git avec Github, et ce pour versionner mon projet et pouvoir faire
							le suivit de ce dernier sur plusieurs postes. En effet, lors des
							horaires de formation j'ai travaillé sur les postes fournis par la
							SOFIP et grâce à git j'ai pu reprendre mon travail chez moi.
							<br /><br />
							<span>BAS</span>
							<br /><br />
							Visual Studio Code a été mon IDE, je l'ai paramétré avec
							différentes extensions pour améliorer mon expérience de
							développement. Avec notamment Eslint (Pour obtenir des règles de
							codage et améliorer le processus de débuggage), Prettier (Pour
							avoir une interface plus lisible), Postman (Pour faire mes tests
							sur la BDD depuis mon IDE directement) et MongoDB for VSCode (Pour
							visualiser ma base de données depuis VSCode)
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Utilisation de Git</h3>
						<img
							src="./image/Branches git.png"
							alt="Schéma illustrant l'usage de différentes branches git, 'main', 'feature' et 'rollback'"
						/>
						<aside class="notes">
							J'ai travaillé sur une branche principale Main que je dérivais en
							une branche Rollback et une branche Feature (git checkout -b
							[nom_de_la_branche]).
							<br /><br />
							La branche RollBack était pour me garantir que l'application
							puisse toujours fonctionner en cas de pépin sur la branche main.
							Apprennant à utiliser Git, cette branche m'a surtout servie de
							filet de sécurité. Je la mettais à jour régulièrement.
							<br /><br />
							Quand à la branche Feature, elle n'existait que pendant le laps de
							temps ou je développer une nouvelle feature puis je la supprimée
							après l'avoir rebase sur la main. (git rebase main). Le nom de mes
							branches ressemblaient a "feature-login" par exemple.
							<br /><br />
							J'effectuais ses manipulations pour chaque feature, mais je n'ai
							pas eu ce réflexe dés le début du projet. C'est quand il a gagné
							en complexité que j'ai senti le besoin de mieux m'organiser.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>MCD</h3>
						<img
							src="./image/MCD.png"
							alt="Schéma du MCD réalisé pour le projet"
						/>
						<aside class="notes">
							Dans mon application, un utilisateur peut être dans l'une des deux
							catégories: Patient ou Médecin. Ils partagent les données liées à
							l'utilisateur. Comme le Prénom, le Nom, le genre, le mot de passe
							de leur compte, l'email (Qui sert d'identifiant de connexion),
							l'adresse, le numéro de téléphone et l'image de profil (Si il y en
							a une de paramétrée).
							<br /><br />
							On ne le voit pas sur un MCD, mais c'est grâce à l'id_user propre
							a chaque utilisateur qui, une fois lié à un patient ou un médecin
							dans la collection correspondante, permet de savoir à quel
							patient/médecin fait référence tel utilisateur. Son rôle permet de
							savoir dans quel collection cherché. Il peut être patient ou
							médecin.
							<br /><br />
							Une rendez-vous est un document comprenant un id_appointment pour
							le rendre unique, une date indiquant quand le rendez-vous à lieu
							(En ce qui concerne sa durée, j'ai considéré que chaque
							rendez-vous durera 30 minutes) et le status qu'il a (Si il est en
							attente, passé ou annulé).
							<br /><br />
							Chaque valeur des documents stockés dans les collections est typée
							puis certaines ont des limitations. Comme le mail : C'est une
							chaîne de caractère qui peut faire 50 caractères maximum et chaque
							email doit être unique dans toute la collection.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Système de gestion de base de données</h3>
						<img
							class="icon"
							src="./image/mongodb-icon-2.svg"
							alt="Icône MongoDB"
						/>
						<p>Base de données non relationnelle orientée documents</p>
						<aside class="notes">
							J'ai donc utilisé MongoDB comme système de gestion de base de
							données. Mon choix à été surtout un choix de confort, je
							connaissais MongoDB grâce aux ateliers pratiqués à la formation et
							c'était relativement simple à utiliser. Cependant j'ai tout de
							même appris des choses lors de ce projet concernant MongoDB.
							Notamment la façon dont il gère les dates stockées et aussi la
							façon dont on peut lier des documents entre eux.
							<br /><br />
							<span>&gt;&gt; DROIT</span>
						</aside>
					</section>
				</section>

				<!-- Backend -->
				<section>
					<h2>Création du backend</h2>
					<section>
						<h3>Structure de service backend</h3>
						<img
							src="./image/structure back.png"
							alt="Schéma représentant la vie d'une requête côté backend"
						/>
						<aside class="notes">
							Pour structuré mon backend, j'ai opté pour l'organisation suivante
							:
							<br /><br />
							Une fois qu'une requête arrive sur mon back, il vérifie que la
							route appelée est correcte
							<br /><br />
							Si c'est le cas, il appelle le controller associé tout en passant
							par les Middlewares de la route si elle en possède. Les
							Middlewares vont alors vérifier la conformité de la requête.
							<br /><br />
							Le controller vérifie que les informations reçues dans la requête
							sont conformes avec ce qui est attendue par le service en bout de
							course de la route.
							<br /><br />
							Le service traite ensuite la demande en effectuant les
							modifications demandées sur la bdd.
							<br /><br />
							Qu'il y ai une erreur de route, un Middleware qui empêche le
							restant de la requête de s'effectuer, que le controller détecte
							que les valeurs reçues ne sont pas bonnes ou que le services ne
							parvient pas a effectuer son opération, il y aura toujours un
							message d'erreur associé qui sera retourné.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Routes</h3>
						<pre>
							<code class="language-javascript">
router.post( "/register/doctor", validate(RegisterDoctorSchema),authController.registerDoctor );
router.post("/login",validate(LoginUserSchema),authController.login);
						</code>
						</pre>
						<aside class="notes">
							Voici deux exemples de routes qui se trouvent dans ma section
							auth.
							<br /><br />
							La première est appelée lors de l'enregistrement d'un médecin. Une
							fois la redirection effectuée, le Middleware validate vérifie que
							les données recues correspondent au Schema 'RegisterDoctorSchema'
							et ensuite la fonction registerDoctor du controller authController
							s'execute afin de réaliser les opérations nécessaires avant
							d'appeler le service usersService.create et doctorsService.create
							afin que l'enregistrement de l'utilisateur soit finalisé
							<br /><br />
							La seconde route, elle, permet de vérifier que les données reçues
							soient conforme avec le Schéma LoginUserSchema et appelle ensuite
							la fonction login du controller authController qui va vérifier que
							les informations reçues existent et correspondent à des
							informations stockées dans la BDD dans la collection Users.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Middlewares</h3>
						<pre>
							<code>
const authenticateUser = (req, _res, next) => {
	const token = req.signedCookies.accessToken || null;

	if (!token) {
		throw new UnauthenticatedError("Pas de token fournit");
	}

	try {
		const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
		const { id, email } = decodedToken;
		req.user = { id, email };

		next();
	} catch (error) {
		throw new UnauthenticatedError("Accès non autorisé");
	}
};
							</code>
						</pre>
						<aside class="notes">
							authenticateUser est un autre Middleware, il vérifie que la
							requête comprend bien un cookie comprenant le token de session
							acessToken. Si c'est le cas, il le décode à l'aide de la clé
							secrète paramétré pour les token JWT dans les variables
							d'environnement et vérifie qu'il est valide. Une fois fait, il
							récupère l'id et l'email présent dedans et l'ajoute à la requête
							sous req.user. Ensuite, il appele le reste de la route pour
							qu'elle s'exécute.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Controllers</h3>
						<pre>
							<code>
const login = async (req, res) => {
	const user = await usersService.get({ email: req.body.email });

	if (!user) {
		throw new UnauthenticatedError("Identifiants invalides.");
	}

	const id = user._id;
	const email = user.email;

	const isPasswordCorrect = await user.comparePasswords(req.body.password);
	if (!isPasswordCorrect) {
		throw new UnauthenticatedError("Identifiants invalides.");
	}

	const token = jwt.sign({ id, email }, process.env.JWT_SECRET, {
		expiresIn: process.env.JWT_LIFETIME,
	});

	const oneDay = 24 * 60 * 60 * 1000;

	res.cookie("accessToken", token, {
		HttpOnly: true,
		secure: process.env.NODE_ENV === "production",
		signed: true,
		expires: new Date(Date.now() + oneDay),
	});

	res.status(StatusCodes.OK).json({ user: { userId: id } });
};
							</code>
						</pre>
						<aside class="notes">
							Un exemple de controller.
							<br /><br />
							Il récupère l'utilisateur associé à l'adresse email contenue dans
							la requête. (user)
							<br /><br />
							Il compare ensuite le mot de passe contenu dans la requête avec
							celui stocké dans la BDD pour l'utilisateur concerné à l'aide de
							user.comparePasswords (Qui est une méthode associé au model user)
							<br /><br />
							Il créé ensuite un token à l'aide de JWT.sign, le stocke dans un
							cookie signé avec une date d'expiration fixée a 24 heures
							<br /><br />
							Et retourne une réponse comprennant l'id de l'utilisateur mais
							aussi le cookie qui vient de créé
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Services</h3>
						<pre>
							<code>
import User from "./users.model.js";

const get = (email) => {
	return User.findOne(email);
};
							</code>
						</pre>
						<aside class="notes">
							Un exemple de service.
							<br /><br />
							Celui ci permet de trouver un utilisateur en fonction de l'email
							reçu en entrée
							<br /><br />
							User fait référence au model des utilisateurs
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Sécurité</h3>
						<ul>
							<li class="fragment">Hachage du mot de passe</li>
							<li class="fragment">Helmet</li>
							<li class="fragment">Json Web Token</li>
							<li class="fragment">Express Rate Limit</li>
							<li class="fragment">MongoSanitize</li>
						</ul>
						<aside class="notes">
							J'ai mis en place des éléments garantissant la sécurité et
							l'intégrité de mon application.
							<br /><br />
							<span> BAS</span>
							<br /><br />
							Le Hachage de mot de passe par grain de sel à l'aide de bcrypt.
							<br /><br />
							<span> BAS</span>
							<br /><br />
							La protection de mes entêtes de requête via Helmet.
							<br /><br />
							<span> BAS</span>
							<br /><br />
							Le système de cookie signé et de vérification de token de session
							via JWT.
							<br /><br />
							<span> BAS</span>
							<br /><br />
							La prévention d'attaque DDOS avec Express Rate Limit.
							<br /><br />
							<span> BAS</span>
							<br /><br />
							La sanitarisation des données reçues à l'aide de MongoSanitize
							pour éviter l'injection de données dans ma BDD.
							<br /><br />
							<span>&gt;&gt; DROIT</span>
						</aside>
					</section>
				</section>

				<!-- Frontend -->
				<section>
					<h2>Création du Frontend</h2>
					<section>
						<h3>Router</h3>
						<pre>
							<code>
path: "/",
element: &lt;SharedLayout /&gt;,
children: [
  {
    index: true,
    element: &lt;Home /&gt;,
    errorElement: &lt;div&gt;Error&lt;/div&gt;,
  },
  {
    path: "appointment/:id?",
    element: &lt;Appointment /&gt;,
    errorElement: &lt;div&gt;Error&lt;/div&gt;,
    action: appointmentAction,
  },
							</code>
						</pre>
						<aside class="notes">
							Afin de structurer mon interface utilisateur, j'ai mis en place un
							layout à l'aide de React Router dom.
							<br /><br />
							Ce layout me permet de définir une structure commune à l'ensemble
							des pages qui lui sont enfants et d'affichés des éléments en
							fonction de la page active.
							<br /><br />
							Ici on peut voir que les pages enfants peuvent afficher le
							composant Home quand on est sur la page d'index, ou encore le
							composant Appointment quand on est sur la page de prise de
							rendez-vous (/appointment)
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Router</h3>
						<pre>
        <code class="language-javascript">
&lt;main className="relative flex min-h-dvh flex-col items-center bg-base-300"&gt;
  &lt;AuthProvider&gt;
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      &lt;RouterProvider router={router} /&gt;
    &lt;/ThemeContext.Provider&gt;
  &lt;/AuthProvider&gt;
&lt;/main&gt;
        </code>
    </pre>
						<aside class="notes">
							Une fois mes routes paramétrées et mon router terminé, je l'ai
							intégré dans deux contextes.
							<br /><br />
							Le permier AuthProvider me permet de gérer la session de
							l'utilisateur et de pouvoir faire appel aux fonctions qu'ils
							comprend partout dans mon application.
							<br /><br />
							Le second, ThemeContext, me permet de gérer le thème actuellement
							selectionné par l'utilisateur (Thème clair ou thème sombre)
							<br /><br />
							PS : J'ai retiré le ToastContainer de la présentation pour gagner
							en visibilité.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Layout</h3>
						<pre>
        <code class="language-javascript">
    &lt;&gt;
      &lt;Navbar /&gt;
      &lt;SideMenuDrawer&gt;
        {isPageLoading ? &lt;Loading /&gt; : &lt;Outlet /&gt;}
      &lt;/SideMenuDrawer&gt;
      &lt;Footer /&gt;
    &lt;/&gt;
        </code>
    </pre>
						<aside class="notes">
							Dans cette structure commune on retrouve la barre de Navigation
							(Navbar) le footer, le SideMenuDrawer (qui est le menu principal
							de mon application) qui lui comprend le outlet qui est l'élément
							représentant le contenu affiché en temps réel en fonction de la
							page active
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Visuel du site</h3>
						<img src="./image/vue_index.png" alt="Vue générale du site" />
						<aside class="notes">
							Voilà le visuel du site avec les éléments mentionnés précédemment.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Visuel du site format mobile</h3>
						<img
							src="./image/vue_index_mobile.png"
							alt="Vue générale du site en format mobile"
						/>
						<aside class="notes">
							Et voici le visuel en version mobile. Le menu de gauche est
							accessible via la flèche qui pointe le bord gauche de la fenêtre.
							La barre de navigation a un affiche conditionnel en fonction de la
							largeur de l'écran. Le ThemeToggler et la barre de recherche
							disparaissent quand l'écran est en format mobile/tablette.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Tailwind et Breakpoint</h3>
						<pre>
							<code class="language-javascript">
&lt;div className="drawer relative flex-1 bg-base-100 lg:drawer-open xl:max-w-screen-xl"&gt;
							</code>
						</pre>
						<aside class="notes">
							Voici un exmple d'usage de tailwind. lg:drawer-open me permet de
							définir le menu latéral comme étant ouvert par défaut et
							xl:max-w-screen-xl me permet de définir la largeur maximale du
							conteneur lorsque la taille de l'écran est en xl ou plus. (1280px)
							<br /><br />
							<span>&gt;&gt; DROIT</span>
						</aside>
					</section>
				</section>

				<!-- Prise de Rendez-vous -->
				<section>
					<h2>Prise de Rendez-vous</h2>
					<section>
						<h3>Spécialisations des médecins</h3>
						<pre>
							<code class="language-javascript">
const getAllSpecialities = async () => {
  try {
    const { data } = await apiClient.get("/api/v1/doctors/specialities");
    setSpecialities(data.specialities);
  } catch (error) {
    const errorMessage =
      error.response?.data?.msg ||
      "Erreur lors de la récupération des types de consultation";
    toast.error(errorMessage);
  }
};
							</code>
						</pre>
						<aside class="notes">
							La fonction getAllSpecialities permet de récupérer toutes les
							spécialités des médecins en faisant un appel sur la route back
							api/v1/doctors/specialities grâce à axios. apiClient est une
							fonction custom que j'ai eu besoin de créer lors du déploiement de
							mon application.
							<br /><br />
							const apiClient = axios.create({ baseURL:
							import.meta.env.API_BASE_URL, });
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Médecins par spécialité</h3>
						<pre>
							<code class="language-javascript">
const getDoctorsBySpeciality = async (speciality) => {
  try {
    const { data } = await apiClient.post("/api/v1/doctors/bySpeciality", {
      speciality,
    });
    return data.doctors;
  } catch (error) {
    const errorMessage =
      error.response?.data?.msg ||
      "Erreur lors de la récupération des médecins";
    toast.error(errorMessage);
  }
};
							</code>
						</pre>
						<aside class="notes">
							Une fois une spécialité de selectionné, la fonction
							getDoctorsBySpeciality est appelée permettant de récupérer tous
							les docteurs ayant comme spécialité celle choisi par
							l'utilisateur.
							<br /><br />
							Je n'ai pas encore géré les éventuelles erreurs qui peuvent
							survenir lors des appels vers le back pour ses routes. La
							fonctionnalité de prise de rendez-vous étant la première que j'ai
							implémenté, ma logique autour de la gestion d'erreur n'était pas
							encore très rôdé.
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Modale de confirmation</h3>
						<pre>
							<code class="language-javascript">
const handleEventClick = async (event) => {
  const updatedValues = {
    doctor: appointmentValues.doctor,
    reservedDate: event.start,
    patient: user._id,
  };

  setAppointmentValues(updatedValues);

  if (modalRef.current) {
    modalRef.current.showModal();
  }

  try {
    const { data } = await apiClient.post("/api/v1/doctors/options", {
      _id: updatedValues.doctor,
    });

    setCurrentDoctor(data.doctors);
  } catch (error) {
    console.log(error);
  }
};
							</code>
						</pre>
						<aside class="notes">
							Une fois que l'utilisateur a choisi le médecin avec qui prendre
							rendez-vous, il choisi un créneau horaire dans le calendrier (Qui
							est lui réalisé avec React Big Calendar) et une modale de
							confirmation apparait. Récapitulant les informations du
							rendez-vous
							<br /><br />
							Patient / Médecin / Date et heure
							<br /><br />
							<span>&gt;&gt; BAS</span>
						</aside>
					</section>
					<section>
						<h3>Action de prise de Rendez-vous</h3>
						<pre>
							<code class="language-javascript">
export const action = async ({ request }) => {
  const formData = await request.formData();
  const doctor = formData.get("doctor");
  const reservedDate = formData.get("reservedDate");
  const patient = formData.get("patient");

  if (!doctor || !reservedDate) {
    throw new Error("Docteur ou date de rendez-vous non sélectionné.");
  }

  try {
    const { data } = await apiClient.post("/api/v1/appointments", {
      date: reservedDate,
      doctorId: doctor,
      patientId: patient,
    });

    toast.success(data.msg);

    return redirect("/");
  } catch (error) {
    const errorMessage =
      error.response?.data?.msg || "Erreur lors de la prise de rendez-vous";
    toast.error(errorMessage);
    return null;
  }
};
							</code>
						</pre>
						<aside class="notes">
							Une fois que l'utilisateur confirme son rendez-vous dans la
							modale, la fonction action est appelée.
							<br /><br />
							Elle récupère les données envoyées à la soumission du formulaire
							pour les stockées dans des variables nommées pour plus de
							facilité, ensuite un appel vers /api/v1/appointments en méthode
							POST permet de créer le rendez-vous et un toast de réussite permet
							d'informer l'utilisateur que son rendez-vous à bien été pris au
							même moment qu'il est redirigé vers l'accueil.
							<br /><br />
							C'est notamment avec cette fonction que j'ai entammé ma logique de
							toast pour informé l'utilisateur des résultats de ses actions. Car
							en effet, j'utilise de nombreuses redirection dans mon application
							suite à des actions de l'utilisateur, de ce fait un message
							informatif présent sur la page n'a pas de sens et la redirection
							vers une page d'erreur n'est pratique que dans le cas d'erreur et
							non de succés.
							<br /><br />
							<span>&gt;&gt; DROIT</span>
						</aside>
					</section>
				</section>

				<!-- Autres réalisation -->
				<section>
					<h2>Autres réalisations</h2>
					<ul>
						<li class="fragment">Système d'authentification</li>
						<li class="fragment">Theme Toggler</li>
						<li class="fragment">Recherche de médecin</li>
						<li class="fragment">Génération d'avatar</li>
					</ul>
					<aside class="notes">
						J'ai également réaliser d'autres fonctionnalités dans l'application
						que je ne peux pas détailler ici, manque de temps. Cependant je vais
						vous les présenter rapidement:
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Le système d'authentification qui gère les sessions utilisateur et
						leur validité, la connexion et la deconnexion.
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Le bouton toggle qui change le thème. Il stocke la préférence de
						l'utilisateur dans le localStorage et le charge à chaque fois qu'il
						se rend sur le site.
						<br /><br />
						<span>BAS</span>
						<br /><br />
						La recherche de médecin, elle permet de trouver un médecin à l'aide
						de la barre de recherche dans la barre de navigation à l'aide d'un
						fragment du nom ou du prénom d'un médecin.
						<br /><br />
						<span>BAS</span>
						<br /><br />
						La génération d'avatar. Une fois connecté, si les informations de
						l'utilisateur reçues ne comprennent pas d'image, il génère une image
						automatiquement à partir du nom et du prénom de l'utilisateur à
						l'aide de DiceBear afin de créer un avatar pour l'utilisateur.
						<br /><br />
						<span>&gt;&gt; DROIT</span>
					</aside>
				</section>

				<!-- Démonstration -->
				<section>
					<h2>Démonstration</h2>
					<section>
						<a href="https://fictif.freyza.net">Démo</a>
						<aside class="notes">
							Je vous propose de faire un test de l'application.
						</aside>
					</section>
				</section>

				<!-- Axes d'amélioration -->
				<section>
					<h2>Axes d'amélioration</h2>
					<ul>
						<li class="fragment">Second portail (Admins/Médecins)</li>
						<li class="fragment">Modifications des rendez-vous</li>
						<li class="fragment">Envoi d'email (Enregistrement/Rendez-vous)</li>
						<li class="fragment">
							Modification de mot de passe requiert l'ancien
						</li>
						<li class="fragment">Fil d'ariane</li>
						<li class="fragment">Gestion plus complète des horaires</li>
						<li class="fragment">Gestion des avatars personnalisés</li>
						<li class="fragment">Génération des créneaux plus dynamique</li>
						<li class="fragment">Auto refresh token</li>
					</ul>
				</section>

				<!-- Conclusion -->
				<section>
					<h2>Conclusion</h2>
					<p class="fragment">Bilan</p>
					<p class="fragment">Remerciements</p>
					<p class="fragment">A vos questions !</p>
					<aside class="notes">
						On arrive donc à la conclusion de ce projet :
						<span>BAS</span>
						<br /><br />
						Au final ce projet m'a permis d'apprendre plein de choses comme
						tailwind, l'utilisation d'un framework d'interface utilisateur comme
						Daisy UI, la conception d'un back end et d'une API, allé plus loin
						dans React et bien sujets encore.
						<br /><br />
						Au global la formation m'a appris énormément de choses, entre le
						moment de mon arrivé et aujourd'hui, je me sens capable d'apporter
						des choses à ce secteur et aussi de m'en nourrir. Je suis très
						enthousiaste à l'idée d'obtenir mes premières missions
						"officielles".
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Un rapide remerciement à mon formateur Thomas Robert pour nous avoir
						partagé ses connaissances, mes camarades de formation qui ont su
						être une source d'inspiration lors de nos échanges, l'équipe qui m'a
						encadré lors de mon stage à AXA France pour leur bienveillance, la
						SOFIP pour l'opportunité offerte et aussi le cadre favorable à
						l'apprentissage assuré par le personnel et enfin vous qui avez suivi
						ma présentation.
						<br /><br />
						<span>BAS</span>
						<br /><br />
						Il me reste plus qu'à vous demander qu'elles sont vos questions !
					</aside>
				</section>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
		<script>
			hljs.highlightAll();
			Reveal.initialize({
				plugins: [RevealNotes],
			});
		</script>
	</body>
</html>
